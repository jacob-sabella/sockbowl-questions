plugins {
	id 'java'
	id 'org.springframework.boot' version '3.3.3'
	id 'io.spring.dependency-management' version '1.1.6'
	id 'maven-publish'
}

ext {
	springAiVersion = "1.0.0-M6"
}

group = 'com.soulsoftworks'
version = '0.0.1-SNAPSHOT'
sourceCompatibility = '17'

repositories {
	mavenCentral()

}

dependencies {
	implementation 'org.springframework.boot:spring-boot-starter'
	implementation 'org.springframework.boot:spring-boot-starter-data-neo4j'
	implementation 'org.springframework.boot:spring-boot-starter-web'
	implementation 'org.springframework.boot:spring-boot-starter-graphql'
	implementation 'com.google.code.gson:gson:2.11.0'
	implementation 'org.springframework.ai:spring-ai-ollama-spring-boot-starter:1.0.0-M6'
	implementation 'org.springframework.ai:spring-ai-neo4j-store-spring-boot-starter:1.0.0-M6'
	implementation 'org.springframework.ai:spring-ai-mcp-client-spring-boot-starter:1.0.0-M6'
	implementation 'com.github.victools:jsonschema-generator:4.38.0'

	compileOnly 'org.projectlombok:lombok:1.18.34'

	annotationProcessor 'org.projectlombok:lombok:1.18.34'
	testCompileOnly 'org.projectlombok:lombok:1.18.34'
	testAnnotationProcessor 'org.projectlombok:lombok:1.18.34'
	runtimeOnly 'org.postgresql:postgresql'
	testImplementation 'org.springframework.boot:spring-boot-starter-test'
}

tasks.named('test') {
	useJUnitPlatform()
}

tasks.register('modelsJar', Jar) {
	group = 'build'
	description = 'Jar containing only com.soulsoftworks.sockbowlquestions.models.* classes'
	from sourceSets.main.output
	include 'com/soulsoftworks/sockbowlquestions/models/**'
	archiveBaseName = 'sockbowlquestions-models'
	// use the project version; no classifier so it looks like a normal library
}

tasks.register('modelsSourcesJar', Jar) {
	group = 'build'
	description = 'Sources jar for the models-only artifact'
	from sourceSets.main.allSource
	include 'com/soulsoftworks/sockbowlquestions/models/**'
	archiveBaseName = 'sockbowlquestions-models'
	archiveClassifier = 'sources'
}

publishing {
	publications {
		// Use register/create with explicit type; keep it isolated from your app publication
		register("models", MavenPublication) {
			groupId = project.group as String
			artifactId = "sockbowlquestions-models"
			version = gitBranchVersion(project) as String

			// Publish your custom JARs (TaskProvider#get is fine in Groovy; explicit here for clarity)
			artifact tasks.named("modelsJar").get()
			artifact tasks.named("modelsSourcesJar").get()

			pom {
				name = "Sockbowl Questions Models"
				description = "Models under com.soulsoftworks.sockbowlquestions.models"
				url = "https://github.com/${System.getenv('GITHUB_REPOSITORY') ?: 'OWNER/REPO'}"

				licenses {
					license {
						name = "Apache License, Version 2.0"
						url = "https://www.apache.org/licenses/LICENSE-2.0"
						distribution = "repo"
					}
				}
				// (optional but nice) Fill these if you plan to sync elsewhere later
				scm {
					def repo = System.getenv('GITHUB_REPOSITORY') ?: 'OWNER/REPO'
					url = "https://github.com/${repo}"
					connection = "scm:git:https://github.com/${repo}.git"
					developerConnection = "scm:git:ssh://git@github.com/${repo}.git"
				}
				developers {
					developer {
						id = "jsabella"
						name = "Jacob Sabella"
					}
				}
			}
		}
	}

	repositories {
		// GitHub Packages (Maven)
		maven {
			name = "GitHubPackages"
			url = uri("https://maven.pkg.github.com/${System.getenv('GITHUB_REPOSITORY') ?: 'OWNER/REPO'}")
			credentials {
				username = (System.getenv("GITHUB_ACTOR") ?: (project.findProperty("gpr.user") ?: "")) as String
				password = (System.getenv("GITHUB_TOKEN") ?: (project.findProperty("gpr.key") ?: "")) as String
			}
		}
	}
}


bootBuildImage {
	createdDate = "now"
	imageName = "jacob-sabella/${project.name}:${gitBranchVersion()}"
}

dependencyManagement {
	imports {
		mavenBom "org.springframework.ai:spring-ai-bom:$springAiVersion"
	}
}

static def gitBranchVersion(def project = null) {

	// 1) Prefer CI-provided names
	String name = System.getenv('GITHUB_REF_NAME')    // e.g. "main" or "feature/x"
	if (!name || name.trim().isEmpty()) {
		name = System.getenv('GITHUB_HEAD_REF')       // e.g. "feature/x" on pull_request
	}
	if (!name || name.trim().isEmpty()) {
		String ref = System.getenv('GITHUB_REF')      // e.g. "refs/heads/main" or "refs/tags/v1.2.3"
		if (ref) {
			// strip common prefixes
			name = ref.replaceFirst('^refs/heads/', '')
					.replaceFirst('^refs/tags/', '')
					.replaceFirst('^refs/pull/', 'PR-') // "PR-123/merge" â†’ handle below
		}
	}

	// 2) Fallback to git only if CI vars are missing
	if (!name || name.trim().isEmpty()) {
		try {
			name = 'git rev-parse --abbrev-ref HEAD'.execute().text.trim()
		} catch (ignored) { /* keep null */ }
	}

	// 3) Normalize weird PR refs like "PR-123/merge"
	if (name?.startsWith('PR-')) {
		name = name.replaceAll('/.*$', '') // "PR-123"
	}

	// 4) Handle detached situations where git returns "HEAD"
	if (!name || name == 'HEAD') {
		return (project?.version ?: '0.0.0') + '-SNAPSHOT'
	}

	// 5) Map to your scheme
	if (name == 'main' || name == 'master') {
		return project?.version ?: '0.0.1-SNAPSHOT'
	} else if (name.startsWith('release/')) {
		return name.substring('release/'.length()) + '-RC'
	} else if (name.startsWith('feature/')) {
		return name.substring('feature/'.length()) + '-SNAPSHOT'
	} else {
		return name + '-SNAPSHOT'
	}
}

